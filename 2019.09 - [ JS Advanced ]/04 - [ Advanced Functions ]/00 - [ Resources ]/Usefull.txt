Function
=> Именован списък от инструкции

First Class
=> Могат да бъдат: създавани, подавани и връщани от други функции

High order function
=> Позволяват ни да връщаме други функции или да декларираме функции
=> Това че връщат функции не означава, че не могат да приемат друга функция

bind
=> да зададете нов контекст на функцията + да и хардкор-ните параметри
Пример:
function foo(a,b,c,d){

};

let bar = foo.bind(undefined,1,2,3); => връща функция, която приема 1 параметър и (вместо undefined по-принцип се слага this)
bar(4); (горе са подадени 3-те параметъра(a=1,b=2,c=3) и тука остава само единият от функцията foo => тоест d=4)

call
=> приема изброени аргументи

apply
=> приема масив от аргументи

Currying
=> Има си ясни правила как се прави
=> Реалната му имплементация е Partial Application
=> Целта е да ни даде резултат => функция с един параметър
=> Да вземем една функция с много параметри
Да я разцепим на малки функции, които взимат по 1 параметър

Partial Application
=> очаква, че функцията едва ли не ще е изпълнена донякъде
докато Currying не я изпълнява => просто създава нова функция и създава нови аргументи
=>  може да направим функцията да има нужда от 1,2,7,15 параметъра

IIFE
=> основно се използва за да създадеш една функция и веднага да се execute-не тази функция

Closure
=> много важно нещо в езика и в езика не се вика Closure а се вика scope

Prototype
=> механизъм за делегриране на функционалност за преизползване на функционалност в езика

Argument
=> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments